{
  "rules": [
    {
      "type": "prd",
      "content": "## Product Requirements Document (PRD)\n\n### 1. Introduction\n\n*   **1.1. Purpose**: This document outlines the requirements for a web-based automation tool designed to streamline communication with conference attendees.\n*   **1.2. Goals**: The primary goals of this tool are to automate the process of sending customized emails to conference attendees based on their specific conditions, reduce manual effort, improve accuracy, and enhance overall efficiency.\n*   **1.3. Target Audience**: This document is intended for the development team, stakeholders, and project managers involved in the creation of this automation tool.\n\n### 2. Goals\n\n*   Automate email sending tasks to save time.\n*   Improve accuracy in email delivery based on attendee conditions.\n\n### 3. Features\n\n*   **3.1. Core Features**:\n    *   **3.1.1. Google Sheets Integration**: Import attendee data from Google Sheets.\n    *   **3.1.2. Email Script Selection and Sending**: Select and send appropriate email scripts based on predefined conditions.\n    *   **3.1.3. Email Sending Result Recording and Management**: Record and manage email sending results.\n*   **3.2. Additional Features**:\n    *   **3.2.1. Email Preview**: Preview emails before sending.\n    *   **3.2.2. Automatic Email Script Generation**: Automatically generate email scripts based on simple information.\n    *   **3.2.3. Dashboard**: Provide a dashboard to display email sending status.\n\n### 4. User Stories\n\n*   As a conference organizer, I want to import attendee data from Google Sheets so that I can easily manage attendee information.\n*   As a conference organizer, I want to select and send appropriate email scripts based on attendee conditions so that I can send customized emails.\n*   As a conference organizer, I want to record and manage email sending results so that I can track the status of email delivery.\n*   As a conference organizer, I want to preview emails before sending so that I can avoid errors.\n*   As a conference organizer, I want to automatically generate email scripts based on simple information so that I can quickly create email content.\n*   As a conference organizer, I want to have a dashboard to display email sending status so that I can monitor the progress of email delivery.\n\n### 5. Requirements\n\n*   **5.1. Functional Requirements**:\n    *   The system must be able to import data from Google Sheets.\n    *   The system must be able to select email scripts based on attendee conditions.\n    *   The system must be able to send emails via Outlook.\n    *   The system must be able to record email sending results.\n    *   The system must provide an email preview feature.\n    *   The system must provide an automatic email script generation feature.\n    *   The system must provide a dashboard to display email sending status.\n*   **5.2. Non-Functional Requirements**:\n    *   The system must be user-friendly and easy to use.\n    *   The system must be reliable and secure.\n    *   The system must be scalable to handle a large number of attendees.\n    *   The system must be responsive and provide quick feedback to users.\n\n### 6. Release Criteria\n\n*   All core features must be fully implemented and tested.\n*   The system must meet all functional and non-functional requirements.\n*   The system must be approved by stakeholders.\n\n### 7. Future Considerations\n\n*   Integration with other platforms (e.g., CRM systems).\n*   Advanced analytics and reporting capabilities.\n*   Mobile app support.",
      "writedAt": "2025-09-18T10:37:06.337Z"
    },
    {
      "type": "architecture",
      "content": "```markdown\n# 기술 요구 사항 문서 (TRD)\n\n## 1. 실행 기술 요약\n- **프로젝트 개요**: 컨퍼런스 참석자와의 커뮤니케이션을 간소화하기 위한 웹 기반 자동화 도구를 개발합니다. 주요 기술적 접근 방식은 React를 사용하여 사용자 인터페이스를 구축하고, Python Flask 백엔드를 통해 데이터 처리 및 API를 제공하며, MySQL 데이터베이스에 데이터를 저장하고, Firebase Authentication으로 사용자 인증을 관리합니다.\n- **핵심 기술 스택**: React, Python, Flask, MySQL, Firebase Authentication, Flask-Uploads\n- **주요 기술 목표**:\n    - 성능: 빠른 응답 시간과 효율적인 데이터 처리 보장\n    - 확장성: 많은 수의 참석자 데이터와 트래픽을 처리할 수 있도록 설계\n    - 안정성: 안정적인 시스템 운영 및 데이터 무결성 유지\n- **중요 기술 가정**:\n    - Google Sheets API 및 Outlook SMTP 서버와의 안정적인 연결을 가정합니다.\n    - Firebase Authentication의 안정적인 인증 서비스를 가정합니다.\n    - 사용자들은 표준 웹 브라우저를 사용하여 시스템에 접속한다고 가정합니다.\n\n## 2. 기술 스택\n\n| 범주             | 기술 / 라이브러리          | 사유 (이 프로젝트에 선택된 이유)                                                                                                                                                                                                                                                                                                                                                                                  |\n| ---------------- | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 프론트엔드        | React                        | 사용자 인터페이스 구축을 위한 컴포넌트 기반의 효율적인 라이브러리입니다. 재사용 가능한 UI 컴포넌트와 빠른 렌더링 성능을 제공하여 사용자 경험을 향상시킵니다.                                                                                                                                                                                                                                                                                       |\n| 백엔드           | Python                     | 쉬운 학습 곡선과 풍부한 라이브러리 생태계를 제공하여 빠른 개발이 가능합니다. Google Sheets API, Outlook SMTP 서버와의 연동에 필요한 라이브러리를 쉽게 사용할 수 있습니다.                                                                                                                                                                                                                                                                                        |\n| 웹 프레임워크     | Flask                        | 간단하고 유연한 웹 프레임워크로, API 서버 구축에 적합합니다. 필요한 기능만 추가하여 사용할 수 있으며, React 프론트엔드와 연동하기 용이합니다.                                                                                                                                                                                                                                                                                               |\n| 데이터베이스       | MySQL                        | 안정적이고 널리 사용되는 관계형 데이터베이스입니다. 대규모 데이터 저장 및 관리에 적합하며, Python과의 연동이 용이합니다.                                                                                                                                                                                                                                                                                                                       |\n| 사용자 인증       | Firebase Authentication    | 안전하고 간편한 사용자 인증 서비스를 제공합니다. 다양한 인증 방식 (이메일/비밀번호, Google, Facebook 등)을 지원하며, 개발자가 직접 인증 시스템을 구축하고 관리하는 부담을 줄여줍니다.                                                                                                                                                                                                                                                                                        |\n| 파일 업로드       | Flask-Uploads                | 파일 업로드 및 관리를 위한 Flask 확장입니다. 이메일 스크립트 생성 시 필요한 템플릿 파일 등을 업로드하고 관리하는 데 사용됩니다.                                                                                                                                                                                                                                                                                                                         |\n| 데이터 처리       | Pandas                       | 데이터 분석 및 처리를 위한 강력한 라이브러리입니다. Google Sheets에서 가져온 데이터를 효율적으로 처리하고, 필요한 형식으로 변환하는 데 사용됩니다.                                                                                                                                                                                                                                                                                                         |\n| 이메일 전송       | smtplib, email (Python)      | Python 표준 라이브러리를 사용하여 이메일 전송 기능을 구현합니다. Outlook SMTP 서버를 통해 이메일을 전송하며, 이메일 내용 (제목, 본문, 첨부 파일 등)을 구성하는 데 필요한 기능을 제공합니다.                                                                                                                                                                                                                                                                                            |\n| Google Sheets API | google-api-python-client   | Google Sheets API를 사용하여 Google Sheets 데이터를 읽어오는 데 사용됩니다.                                                                                                                                                                                                                                                                                                                                |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n- **프론트엔드 (React)**:\n    - 사용자 인터페이스 및 사용자 상호 작용 처리\n    - API 요청을 백엔드로 전송\n    - 데이터 시각화 (대시보드)\n- **백엔드 (Python Flask)**:\n    - API 엔드포인트 제공\n    - Google Sheets 데이터 처리 및 관리\n    - 이메일 스크립트 처리 및 전송\n    - 데이터베이스 상호 작용\n    - Firebase Authentication을 통한 사용자 인증\n- **데이터베이스 (MySQL)**:\n    - 참석자 데이터, 이메일 스크립트, 전송 결과 저장\n- **Firebase Authentication**:\n    - 사용자 인증 및 권한 관리\n\n### 최상위 컴포넌트 상호 작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (React)] --> B[Backend (Flask)]\n    B --> C[Database (MySQL)]\n    B --> D[Firebase Authentication]\n    B --> E[Google Sheets API]\n    B --> F[Outlook SMTP Server]\n```\n\n- 프론트엔드 (React)는 사용자의 요청에 따라 백엔드 (Flask)에 API 요청을 전송합니다.\n- 백엔드 (Flask)는 데이터베이스 (MySQL)에 데이터를 저장하거나 조회합니다.\n- 백엔드 (Flask)는 Firebase Authentication을 사용하여 사용자를 인증하고 권한을 확인합니다.\n- 백엔드 (Flask)는 Google Sheets API를 사용하여 Google Sheets에서 참석자 데이터를 가져옵니다.\n- 백엔드 (Flask)는 Outlook SMTP Server를 사용하여 이메일을 전송합니다.\n\n### 코드 구성 및 규칙\n**도메인 기반 구성 전략**\n- **도메인 분리**: 사용자 관리, 이메일 관리, 데이터 관리와 같은 비즈니스 도메인별로 코드를 구성합니다.\n- **계층 기반 아키텍처**: 프레젠테이션 (React 컴포넌트), 비즈니스 로직 (Flask 서비스), 데이터 액세스 (MySQL 모델) 계층으로 구분합니다.\n- **기능 기반 모듈**: 특정 기능을 수행하는 코드 (예: 이메일 전송, 데이터 가져오기)를 하나의 모듈로 묶습니다.\n- **공유 컴포넌트**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 전용 공유 모듈에 배치합니다.\n\n**범용 파일 및 폴더 구조**\n```\n/\n├── frontend/                  # React 프론트엔드 코드\n│   ├── src/                 # 소스 코드\n│   │   ├── components/      # 재사용 가능한 UI 컴포넌트\n│   │   ├── pages/           # 페이지별 컴포넌트\n│   │   ├── services/        # API 호출 및 데이터 처리\n│   │   ├── App.js           # 메인 애플리케이션 컴포넌트\n│   │   └── index.js         # 진입점\n│   ├── public/              # 정적 파일 (HTML, CSS, 이미지)\n│   └── package.json         # npm 패키지 설정\n├── backend/                   # Python Flask 백엔드 코드\n│   ├── app.py               # 메인 애플리케이션 파일\n│   ├── models.py            # 데이터베이스 모델\n│   ├── routes/              # API 엔드포인트 정의\n│   │   ├── user.py          # 사용자 관련 API\n│   │   ├── email.py         # 이메일 관련 API\n│   │   └── data.py          # 데이터 관련 API\n│   ├── services/            # 비즈니스 로직\n│   │   ├── user_service.py  # 사용자 관련 서비스\n│   │   ├── email_service.py # 이메일 관련 서비스\n│   │   └── data_service.py  # 데이터 관련 서비스\n│   ├── config.py            # 설정 파일\n│   └── requirements.txt     # Python 패키지 목록\n├── database/                  # 데이터베이스 관련 파일\n│   └── schema.sql           # 데이터베이스 스키마 정의\n├── scripts/                   # 배포 및 관리 스크립트\n│   └── deploy.sh            # 배포 스크립트\n└── README.md                # 프로젝트 설명서\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: React 프론트엔드는 Flask 백엔드에 API 요청을 보내고, 백엔드는 JSON 형식으로 응답합니다.\n- **데이터베이스 상호 작용**: Flask 백엔드는 SQLAlchemy ORM을 사용하여 MySQL 데이터베이스와 상호 작용합니다.\n- **외부 서비스 통합**: Google Sheets API 및 Outlook SMTP 서버는 Python 라이브러리를 통해 통합됩니다.\n- **실시간 통신**: 대시보드 업데이트를 위해 필요에 따라 WebSocket 또는 SSE를 구현할 수 있습니다.\n- **데이터 동기화**: 데이터베이스와 Google Sheets 간의 데이터 동기화를 위해 주기적인 데이터 업데이트 작업을 수행합니다.\n\n## 4. 성능 및 최적화 전략\n\n- 데이터베이스 쿼리 최적화: 인덱싱 및 쿼리 튜닝을 통해 데이터베이스 쿼리 성능을 향상시킵니다.\n- API 응답 캐싱: 자주 사용되는 API 응답을 캐싱하여 응답 시간을 단축합니다.\n- 이미지 최적화: 이미지 크기를 최적화하여 페이지 로딩 속도를 향상시킵니다.\n- 코드 분할: React 컴포넌트를 코드 분할하여 초기 로딩 시간을 단축합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n### 1단계: 기반 (MVP 구현)\n- **핵심 인프라**: 기본 시스템 설정 및 필수 구성 요소 (React, Flask, MySQL, Firebase Authentication)\n- **필수 기능**: Google Sheets 데이터 가져오기, 이메일 스크립트 선택 및 전송, 이메일 전송 결과 기록 및 관리\n- **기본 보안**: 사용자 인증 및 권한 관리\n- **개발 설정**: 개발 환경 설정 및 CI/CD 기본 설정\n- **타임라인**: 4주\n\n### 2단계: 기능 개선\n- **고급 기능**: 이메일 미리보기, 자동 이메일 스크립트 생성, 대시보드\n- **성능 최적화**: 시스템 성능 개선\n- **보안 강화**: 고급 보안 기능 및 규정 준수\n- **모니터링 구현**: 포괄적인 관찰 기능 설정\n- **타임라인**: 8주\n\n## 6. 위험 평가 및 완화 전략\n### 기술적 위험 분석\n- **기술 위험**: Google Sheets API, Outlook SMTP 서버와의 통합 문제, Firebase Authentication의 의존성\n- **성능 위험**: 대규모 데이터 처리 및 높은 트래픽으로 인한 성능 저하\n- **보안 위험**: 사용자 데이터 및 시스템 보안 취약점\n- **통합 위험**: 타사 서비스 의존성 및 실패 가능성\n- **완화 전략**:\n    - Google Sheets API 및 Outlook SMTP 서버와의 통합 테스트를 충분히 수행합니다.\n    - 성능 테스트를 통해 병목 현상을 식별하고 최적화합니다.\n    - 보안 취약점을 정기적으로 점검하고 패치를 적용합니다.\n    - 타사 서비스 장애에 대비하여 대체 솔루션을 준비합니다.\n\n### 프로젝트 납기 위험\n- **타임라인 위험**: 개발 일정 지연 및 의존성\n- **리소스 위험**: 팀 역량 및 기술 전문성 부족\n- **품질 위험**: 코드 품질 및 테스트 범위 부족\n- **배포 위험**: 프로덕션 배포 및 환경 문제\n- **비상 계획**:\n    - 개발 일정을 현실적으로 조정하고, 중요한 기능부터 우선적으로 개발합니다.\n    - 추가 리소스를 확보하거나 외부 전문가의 도움을 받습니다.\n    - 코드 리뷰 및 테스트를 강화하여 코드 품질을 향상시킵니다.\n    - 배포 전에 충분한 테스트를 수행하고, 롤백 계획을 준비합니다.\n```",
      "writedAt": "2025-09-18T10:37:06.337Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline\n\n## 1. Project Overview\n\nThis project is a web-based automation tool designed to streamline communication with conference attendees. It utilizes React for the frontend, Python Flask for the backend, MySQL for the database, and Firebase Authentication for user authentication. Key architectural decisions include a component-based frontend, a RESTful API backend, and a domain-driven code organization.\n\n## 2. Core Principles\n\n*   **Readability**: Code must be easily understood by other developers.\n*   **Maintainability**: Code must be structured for easy modification and updates.\n*   **Testability**: Code must be written in a way that facilitates unit and integration testing.\n*   **Efficiency**: Code should perform optimally with minimal resource usage.\n*   **Security**: Code must protect user data and prevent vulnerabilities.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. React (Frontend)\n\n#### File Organization and Directory Structure\n\n*   Components should be organized into directories based on their function or feature.\n*   Each component directory should contain the component's JavaScript file (e.g., `MyComponent.js`), CSS module (e.g., `MyComponent.module.css`), and any related test files (e.g., `MyComponent.test.js`).\n*   Shared components should be placed in a `components` directory.\n*   Page-level components should be placed in a `pages` directory.\n*   API service calls should be placed in a `services` directory.\n\nExample:\n\n```\nsrc/\n├── components/\n│   ├── Button/\n│   │   ├── Button.js\n│   │   ├── Button.module.css\n│   │   └── Button.test.js\n│   └── Input/\n│       ├── Input.js\n│       ├── Input.module.css\n│       └── Input.test.js\n├── pages/\n│   ├── Home/\n│   │   ├── Home.js\n│   │   └── Home.module.css\n│   └── AttendeeList/\n│       ├── AttendeeList.js\n│       └── AttendeeList.module.css\n├── services/\n│   └── attendeeService.js\n└── App.js\n```\n\n#### Import/Dependency Management\n\n*   Use absolute imports for modules within the `src` directory.\n*   Group imports by their source (e.g., libraries, components, styles).\n*   Alphabetize imports within each group.\n\nExample:\n\n```javascript\n// React Component\nimport React from 'react';\n\n// External Libraries\nimport axios from 'axios';\n\n// Internal Components\nimport Button from 'components/Button/Button';\nimport Input from 'components/Input/Input';\n\n// Styles\nimport styles from './Home.module.css';\n```\n\n#### Error Handling Patterns\n\n*   Use `try...catch` blocks to handle potential errors during API calls or data processing.\n*   Display user-friendly error messages to the user.\n*   Log errors to the console or a logging service for debugging.\n\nExample:\n\n```javascript\nasync function fetchData() {\n    try {\n        const response = await axios.get('/api/attendees');\n        setData(response.data);\n    } catch (error) {\n        console.error('Error fetching data:', error);\n        alert('Failed to fetch attendee data. Please try again later.');\n    }\n}\n```\n\n### 3.2. Python/Flask (Backend)\n\n#### File Organization and Directory Structure\n\n*   Follow a modular structure with clear separation of concerns.\n*   Use blueprints to organize routes into logical groups (e.g., `user`, `email`, `data`).\n*   Place database models in a `models.py` file.\n*   Place business logic in a `services` directory.\n*   Configuration settings should be in a `config.py` file.\n\nExample:\n\n```\nbackend/\n├── app.py\n├── models.py\n├── routes/\n│   ├── user.py\n│   ├── email.py\n│   └── data.py\n├── services/\n│   ├── user_service.py\n│   ├── email_service.py\n│   └── data_service.py\n├── config.py\n└── requirements.txt\n```\n\n#### Import/Dependency Management\n\n*   Use `requirements.txt` to manage project dependencies.\n*   Use virtual environments to isolate project dependencies.\n*   Avoid circular dependencies.\n*   Import specific modules or functions instead of entire libraries when possible.\n\nExample:\n\n```python\n# Correct\nfrom flask import Flask, request, jsonify\n\n# Avoid\nimport flask\n```\n\n#### Error Handling Patterns\n\n*   Use `try...except` blocks to handle potential exceptions.\n*   Implement custom error handlers for specific error types.\n*   Return appropriate HTTP status codes and error messages in API responses.\n*   Log errors to a logging service.\n\nExample:\n\n```python\nfrom flask import Flask, jsonify\nfrom werkzeug.exceptions import NotFound\n\napp = Flask(__name__)\n\n@app.errorhandler(NotFound)\ndef handle_not_found(e):\n    return jsonify(error=str(e)), 404\n\n@app.route('/attendees/<int:id>')\ndef get_attendee(id):\n    try:\n        attendee = get_attendee_from_db(id)\n        return jsonify(attendee)\n    except NotFound as e:\n        raise e  # Re-raise the exception to be handled by the error handler\n    except Exception as e:\n        app.logger.error(f\"Error fetching attendee {id}: {e}\")\n        return jsonify(error=\"Internal Server Error\"), 500\n```\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow:\n\n*   **Naming Conventions**:\n    *   **Rationale**: Consistent naming improves readability and maintainability.\n    *   Variables: Use camelCase (e.g., `attendeeName`).\n    *   Functions: Use camelCase (e.g., `getAttendeeData()`).\n    *   Classes: Use PascalCase (e.g., `AttendeeService`).\n    *   Constants: Use UPPER_SNAKE_CASE (e.g., `MAX_ATTENDEES`).\n    *   React components: Use PascalCase (e.g., `AttendeeList`).\n    *   Python files: Use lowercase with underscores (e.g., `attendee_service.py`).\n*   **Indentation**:\n    *   **Rationale**: Consistent indentation enhances code structure and readability.\n    *   Use 4 spaces for indentation in both React and Python.\n*   **Comments**:\n    *   **Rationale**: Comments explain the purpose and functionality of code.\n    *   Write clear and concise comments to explain complex logic or non-obvious code.\n    *   Use JSDoc style comments for React components and functions.\n    *   Use docstrings for Python functions and classes.\n*   **Code Formatting**:\n    *   **Rationale**: Consistent formatting improves code aesthetics and reduces visual noise.\n    *   Use a code formatter (e.g., Prettier for React, Black for Python) to automatically format code according to a consistent style.\n*   **Error Handling**:\n    *   **Rationale**: Proper error handling prevents unexpected crashes and provides useful debugging information.\n    *   Always handle potential exceptions using `try...catch` (JavaScript) or `try...except` (Python) blocks.\n    *   Log errors with sufficient context to facilitate debugging.\n*   **API Endpoint Design**:\n    *   **Rationale**: Well-designed APIs are easier to use and maintain.\n    *   Use RESTful principles for API design.\n    *   Use meaningful and consistent endpoint names.\n    *   Return appropriate HTTP status codes.\n    *   Use JSON for request and response bodies.\n*   **State Management (React)**:\n    *   **Rationale**: Structured state management prevents prop drilling and simplifies data flow.\n    *   Use React Context or a state management library (e.g., Redux, Zustand) for managing global state.\n    *   Keep component state minimal and focused on UI-related data.\n\n### 4.2. MUST NOT Do:\n\n*   **Global Variables**:\n    *   **Rationale**: Global variables can lead to naming conflicts and unpredictable behavior.\n    *   Avoid using global variables. Use module-level variables or dependency injection instead.\n*   **Magic Numbers**:\n    *   **Rationale**: Magic numbers make code difficult to understand and maintain.\n    *   Avoid using hardcoded numerical values without explanation. Define constants with meaningful names instead.\n*   **Nested Callbacks**:\n    *   **Rationale**: Nested callbacks can make code difficult to read and debug (callback hell).\n    *   Avoid excessive nesting of callbacks. Use Promises, async/await, or other techniques to flatten asynchronous code.\n*   **Ignoring Errors**:\n    *   **Rationale**: Ignoring errors can lead to unexpected behavior and make it difficult to diagnose problems.\n    *   Never ignore errors. Always handle exceptions or log errors appropriately.\n*   **Hardcoding Credentials**:\n    *   **Rationale**: Hardcoding credentials poses a security risk.\n    *   Never hardcode sensitive information such as API keys or database passwords directly in the code. Use environment variables or a secure configuration management system.\n*   **Over-commenting**:\n    *   **Rationale**: Over-commenting can clutter code and make it harder to read.\n    *   Write clear, concise code that is self-explanatory where possible. Focus comments on explaining complex logic or non-obvious behavior.\n*   **Console.log in Production**:\n    *   **Rationale**: `console.log` statements can expose sensitive information and impact performance.\n    *   Remove or disable `console.log` statements in production code. Use a logging service instead.\n*   **Mutating Props Directly (React)**:\n    *   **Rationale**: Mutating props directly violates the unidirectional data flow in React and can lead to unexpected behavior.\n    *   Treat props as immutable. If you need to modify data, create a copy or derive a new value.\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n*   **React Components**:\n    *   Follow a component-based architecture.\n    *   Create small, reusable components with a single responsibility.\n    *   Use functional components with hooks for state management and side effects.\n    *   Separate UI logic from business logic.\n*   **Flask Modules**:\n    *   Organize code into modules based on functionality.\n    *   Use blueprints to group related routes.\n    *   Create service classes to encapsulate business logic.\n    *   Use models to represent database entities.\n\n### 5.2. Data Flow Patterns\n\n*   **React Frontend**:\n    *   Unidirectional data flow: Data flows from parent components to child components via props.\n    *   State updates trigger re-renders.\n    *   Use event handlers to update state.\n*   **Flask Backend**:\n    *   RESTful API: Clients send requests to API endpoints.\n    *   The backend processes requests and returns JSON responses.\n    *   Use SQLAlchemy ORM to interact with the database.\n\n### 5.3. State Management Conventions (React)\n\n*   **Local State**: Use `useState` hook for component-specific state.\n*   **Context API**: Use `Context` for sharing state between components without prop drilling.\n*   **Redux/Zustand**: Use a state management library for managing global application state.\n\nExample (React Context):\n\n```javascript\n// Create a context\nconst AttendeeContext = React.createContext();\n\n// Create a provider component\nfunction AttendeeProvider({ children }) {\n    const [attendees, setAttendees] = React.useState([]);\n\n    const value = {\n        attendees,\n        setAttendees,\n    };\n\n    return (\n        <AttendeeContext.Provider value={value}>\n            {children}\n        </AttendeeContext.Provider>\n    );\n}\n\n// Use the context in a component\nfunction AttendeeList() {\n    const { attendees } = React.useContext(AttendeeContext);\n\n    return (\n        <ul>\n            {attendees.map(attendee => (\n                <li key={attendee.id}>{attendee.name}</li>\n            ))}\n        </ul>\n    );\n}\n```\n\n### 5.4. API Design Standards\n\n*   Use RESTful principles.\n*   Use meaningful and consistent endpoint names.\n*   Return appropriate HTTP status codes.\n*   Use JSON for request and response bodies.\n*   Implement pagination for large datasets.\n*   Implement versioning for API changes.\n\nExample:\n\n*   `GET /attendees`: Retrieve a list of attendees.\n*   `GET /attendees/{id}`: Retrieve a specific attendee.\n*   `POST /attendees`: Create a new attendee.\n*   `PUT /attendees/{id}`: Update an existing attendee.\n*   `DELETE /attendees/{id}`: Delete an attendee.\n",
      "writedAt": "2025-09-18T10:37:06.337Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-18T10:37:06.337Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-18T10:37:06.337Z"
    }
  ]
}